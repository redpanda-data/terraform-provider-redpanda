// Copyright 2023 Redpanda Data, Inc.
//
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.

package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"text/template"
)

// extractorTemplate is the Go program that imports the schema package,
// calls the schema function, and outputs JSON to stdout
const extractorTemplate = `// Code generated by modelgen. DO NOT EDIT.
package main

import (
	{{if .NeedsContext -}}
	"context"
	{{end -}}
	"encoding/json"
	"os"
	"reflect"

	target "{{.PkgPath}}"
)

type SchemaInfo struct {
	Description string          ` + "`json:\"description\"`" + `
	Attributes  []AttributeInfo ` + "`json:\"attributes\"`" + `
	HasTimeouts bool            ` + "`json:\"has_timeouts\"`" + `
}

type AttributeInfo struct {
	Name       string ` + "`json:\"name\"`" + `
	Type       string ` + "`json:\"type\"`" + `
	Required   bool   ` + "`json:\"required\"`" + `
	Optional   bool   ` + "`json:\"optional\"`" + `
	Computed   bool   ` + "`json:\"computed\"`" + `
	Sensitive  bool   ` + "`json:\"sensitive\"`" + `
	Deprecated bool   ` + "`json:\"deprecated\"`" + `
}

func main() {
	{{if .NeedsContext -}}
	schema := target.{{.FuncName}}(context.Background())
	{{- else -}}
	schema := target.{{.FuncName}}()
	{{- end}}
	info := extractSchemaInfo(schema)
	if err := json.NewEncoder(os.Stdout).Encode(info); err != nil {
		os.Stderr.WriteString("error encoding schema info: " + err.Error())
		os.Exit(1)
	}
}

func extractSchemaInfo(schema interface{}) SchemaInfo {
	info := SchemaInfo{}

	schemaVal := reflect.ValueOf(schema)
	if schemaVal.Kind() == reflect.Ptr {
		schemaVal = schemaVal.Elem()
	}

	// Get Description
	if descField := schemaVal.FieldByName("Description"); descField.IsValid() {
		info.Description = descField.String()
	}

	// Get Attributes
	attrsField := schemaVal.FieldByName("Attributes")
	if attrsField.IsValid() && attrsField.Kind() == reflect.Map {
		for _, key := range attrsField.MapKeys() {
			attrName := key.String()
			attrVal := attrsField.MapIndex(key)

			// Skip timeouts - they're handled separately
			if attrName == "timeouts" {
				info.HasTimeouts = true
				continue
			}

			attrInfo := extractAttributeInfo(attrName, attrVal)
			info.Attributes = append(info.Attributes, attrInfo)
		}
	}

	return info
}

func extractAttributeInfo(name string, attr reflect.Value) AttributeInfo {
	info := AttributeInfo{Name: name}

	// Get the concrete type if it's an interface
	if attr.Kind() == reflect.Interface {
		attr = attr.Elem()
	}

	// Get the type name
	info.Type = attr.Type().Name()

	// Try to get Required field
	if reqField := attr.FieldByName("Required"); reqField.IsValid() && reqField.Kind() == reflect.Bool {
		info.Required = reqField.Bool()
	}

	// Try to get Optional field
	if optField := attr.FieldByName("Optional"); optField.IsValid() && optField.Kind() == reflect.Bool {
		info.Optional = optField.Bool()
	}

	// Try to get Computed field
	if compField := attr.FieldByName("Computed"); compField.IsValid() && compField.Kind() == reflect.Bool {
		info.Computed = compField.Bool()
	}

	// Try to get Sensitive field
	if sensField := attr.FieldByName("Sensitive"); sensField.IsValid() && sensField.Kind() == reflect.Bool {
		info.Sensitive = sensField.Bool()
	}

	// Try to get DeprecationMessage field (non-empty means deprecated)
	if depField := attr.FieldByName("DeprecationMessage"); depField.IsValid() && depField.Kind() == reflect.String {
		info.Deprecated = depField.String() != ""
	}

	return info
}
`

// extractSchema creates a temporary Go program that imports the target package,
// calls the schema function, and outputs the schema information as JSON.
func extractSchema(pkgPath, funcName, schemaType string, needsContext bool) (*SchemaInfo, error) {
	tmpDir, err := os.MkdirTemp("", "modelgen-*")
	if err != nil {
		return nil, fmt.Errorf("failed to create temp directory: %w", err)
	}
	defer os.RemoveAll(tmpDir)

	tmpl, err := template.New("extractor").Parse(extractorTemplate)
	if err != nil {
		return nil, fmt.Errorf("failed to parse extractor template: %w", err)
	}

	data := struct {
		PkgPath      string
		FuncName     string
		SchemaType   string
		NeedsContext bool
	}{
		PkgPath:      pkgPath,
		FuncName:     funcName,
		SchemaType:   schemaType,
		NeedsContext: needsContext,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return nil, fmt.Errorf("failed to execute extractor template: %w", err)
	}

	extractorPath := filepath.Join(tmpDir, "main.go")
	if err := os.WriteFile(extractorPath, buf.Bytes(), filePermissionMode); err != nil {
		return nil, fmt.Errorf("failed to write extractor program: %w", err)
	}

	goModContent := fmt.Sprintf(`module modelgen-extractor

go 1.21

require github.com/redpanda-data/terraform-provider-redpanda v0.0.0

replace github.com/redpanda-data/terraform-provider-redpanda => %s
`, getModuleRoot())

	if err := os.WriteFile(filepath.Join(tmpDir, "go.mod"), []byte(goModContent), filePermissionMode); err != nil {
		return nil, fmt.Errorf("failed to write go.mod: %w", err)
	}

	tidyCmd := exec.Command("go", "mod", "tidy")
	tidyCmd.Dir = tmpDir
	tidyCmd.Stderr = os.Stderr
	if err := tidyCmd.Run(); err != nil {
		return nil, fmt.Errorf("failed to run go mod tidy: %w", err)
	}

	runCmd := exec.Command("go", "run", ".")
	runCmd.Dir = tmpDir
	var stdout, stderr bytes.Buffer
	runCmd.Stdout = &stdout
	runCmd.Stderr = &stderr
	if err := runCmd.Run(); err != nil {
		return nil, fmt.Errorf("failed to run extractor: %w\nstderr: %s", err, stderr.String())
	}

	var info SchemaInfo
	if err := json.Unmarshal(stdout.Bytes(), &info); err != nil {
		return nil, fmt.Errorf("failed to parse extractor output: %w\noutput: %s", err, stdout.String())
	}

	return &info, nil
}

// getModuleRoot returns the root directory of the current Go module
func getModuleRoot() string {
	dir, err := os.Getwd()
	if err != nil {
		return "."
	}

	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			return "."
		}
		dir = parent
	}
}
