// Copyright 2023 Redpanda Data, Inc.
//
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.

package testutil_test

import (
	"context"
	"testing"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	clustermodels "github.com/redpanda-data/terraform-provider-redpanda/redpanda/models/cluster"
	clusterresource "github.com/redpanda-data/terraform-provider-redpanda/redpanda/resources/cluster"
	"github.com/redpanda-data/terraform-provider-redpanda/redpanda/utils/testutil"
)

// Test tables (allResourceTests and allDataSourceTests) are automatically generated
// by running: go generate ./redpanda/models

// TestAllResourceSchemaModelAlignment validates all resource schema-model pairs in a single table-driven test.
// The test cases are automatically generated by running: go generate ./redpanda/models
func TestAllResourceSchemaModelAlignment(t *testing.T) {
	for _, tt := range allResourceTests {
		t.Run(tt.name, func(t *testing.T) {
			req := resource.SchemaRequest{}
			resp := &resource.SchemaResponse{}
			tt.resource.Schema(context.Background(), req, resp)

			if resp.Diagnostics.HasError() {
				t.Fatalf("Failed to get schema: %v", resp.Diagnostics.Errors())
			}

			testutil.ValidateSchemaModelAlignment(t, tt.model, resp.Schema)
		})
	}
}

// TestAllDataSourceSchemaModelAlignment validates all data source schema-model pairs in a single table-driven test.
// The test cases are automatically generated by running: go generate ./redpanda/models
func TestAllDataSourceSchemaModelAlignment(t *testing.T) {
	for _, tt := range allDataSourceTests {
		t.Run(tt.name, func(t *testing.T) {
			req := datasource.SchemaRequest{}
			resp := &datasource.SchemaResponse{}
			tt.dataSource.Schema(context.Background(), req, resp)

			if resp.Diagnostics.HasError() {
				t.Fatalf("Failed to get schema: %v", resp.Diagnostics.Errors())
			}

			testutil.ValidateDataSourceSchemaModelAlignment(t, tt.model, resp.Schema)
		})
	}
}

// TestNestedListAttributeElementType is a regression test that verifies
// that the ElementType of a ListAttribute in a nested object is properly validated.
//
// This test specifically addresses the bug where principal_mapping_rules
// (a ListAttribute with ElementType: types.StringType inside a nested mtls object)
// could be changed to ElementType: types.BoolType without the validator catching it.
func TestNestedListAttributeElementType(t *testing.T) {
	t.Run("ShouldPassWithCorrectElementType", func(t *testing.T) {
		// Define a model using native Go types for nested structures
		// This allows the validator to check element types
		type MtlsModel struct {
			Enabled               bool     `tfsdk:"enabled"`
			PrincipalMappingRules []string `tfsdk:"principal_mapping_rules"`
		}
		type KafkaAPIModel struct {
			Mtls MtlsModel `tfsdk:"mtls"`
		}
		type TestModel struct {
			KafkaAPI KafkaAPIModel `tfsdk:"kafka_api"`
		}

		// Create a schema with CORRECT ElementType (StringType)
		correctSchema := schema.Schema{
			Attributes: map[string]schema.Attribute{
				"kafka_api": schema.SingleNestedAttribute{
					Optional: true,
					Attributes: map[string]schema.Attribute{
						"mtls": schema.SingleNestedAttribute{
							Optional: true,
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									Optional: true,
								},
								"principal_mapping_rules": schema.ListAttribute{
									ElementType: types.StringType, // CORRECT!
									Optional:    true,
								},
							},
						},
					},
				},
			},
		}

		// This should pass without errors
		testutil.ValidateSchemaModelAlignment(t, TestModel{}, correctSchema)
	})

	t.Run("ValidateClusterMtlsSchemaAgainstTypeDefinition", func(t *testing.T) {
		// This test validates the actual cluster schema's nested MTLS configuration
		// against the type definition to catch ElementType mismatches
		// Get the actual cluster schema
		cluster := &clusterresource.Cluster{}
		req := resource.SchemaRequest{}
		resp := &resource.SchemaResponse{}
		cluster.Schema(context.Background(), req, resp)

		if resp.Diagnostics.HasError() {
			t.Fatalf("Failed to get cluster schema: %v", resp.Diagnostics.Errors())
		}

		// Get the kafka_api.mtls schema
		kafkaAPIAttr, ok := resp.Schema.Attributes["kafka_api"]
		if !ok {
			t.Fatal("kafka_api attribute not found in cluster schema")
		}

		kafkaAPINested, ok := kafkaAPIAttr.(schema.SingleNestedAttribute)
		if !ok {
			t.Fatal("kafka_api is not a SingleNestedAttribute")
		}

		mtlsAttr, ok := kafkaAPINested.Attributes["mtls"]
		if !ok {
			t.Fatal("mtls attribute not found in kafka_api schema")
		}

		mtlsNested, ok := mtlsAttr.(schema.SingleNestedAttribute)
		if !ok {
			t.Fatal("mtls is not a SingleNestedAttribute")
		}

		// Validate the actual schema against the type definition
		testutil.ValidateSchemaAgainstObjectType(t, mtlsNested.Attributes, clustermodels.GetMtlsType(), "kafka_api.mtls")
	})

	t.Run("ValidateClusterHTTPProxySchemaAgainstTypeDefinition", func(t *testing.T) {
		// This test validates HTTP Proxy configuration including primitive attribute types
		// It will catch if someone changes "url" from StringAttribute to BoolAttribute
		cluster := &clusterresource.Cluster{}
		req := resource.SchemaRequest{}
		resp := &resource.SchemaResponse{}
		cluster.Schema(context.Background(), req, resp)

		if resp.Diagnostics.HasError() {
			t.Fatalf("Failed to get cluster schema: %v", resp.Diagnostics.Errors())
		}

		// Get the http_proxy schema
		httpProxyAttr, ok := resp.Schema.Attributes["http_proxy"]
		if !ok {
			t.Fatal("http_proxy attribute not found in cluster schema")
		}

		httpProxyNested, ok := httpProxyAttr.(schema.SingleNestedAttribute)
		if !ok {
			t.Fatal("http_proxy is not a SingleNestedAttribute")
		}

		// Validate the actual schema against the type definition
		// This will catch if "url" is BoolAttribute instead of StringAttribute
		testutil.ValidateSchemaAgainstObjectType(t, httpProxyNested.Attributes, clustermodels.GetHTTPProxyType(), "http_proxy")
	})
}

// TestClusterNestedObjectValidation validates all discovered nested objects in the cluster schema
// This test is automatically generated and ensures all nested SingleNestedAttribute fields
// are validated against their type definitions
func TestClusterNestedObjectValidation(t *testing.T) {
	cluster := &clusterresource.Cluster{}
	req := resource.SchemaRequest{}
	resp := &resource.SchemaResponse{}
	cluster.Schema(context.Background(), req, resp)

	if resp.Diagnostics.HasError() {
		t.Fatalf("Failed to get cluster schema: %v", resp.Diagnostics.Errors())
	}

	for _, validation := range clusterNestedObjectValidations {
		t.Run(validation.attributeName, func(t *testing.T) {
			attr, ok := resp.Schema.Attributes[validation.attributeName]
			if !ok {
				t.Fatalf("Attribute %s not found in schema", validation.attributeName)
			}

			nested, ok := attr.(schema.SingleNestedAttribute)
			if !ok {
				t.Fatalf("Attribute %s is not a SingleNestedAttribute", validation.attributeName)
			}

			testutil.ValidateSchemaAgainstObjectType(t, nested.Attributes, validation.typeDefFunc(), validation.attributeName)
		})
	}
}

// TestNestedAttributeValidationWithErrors demonstrates the validation system's ability to detect
// errors in nested attributes, including wrong primitive types and wrong ElementTypes.
//
// This test includes:
// - ValidateCorrectNestedAttributes: A passing test showing correct schema/type definition alignment
// - DEMO tests (skipped): Tests with intentional errors to demonstrate validation capabilities
//
// To see error detection in action:
//
//	go test -v ./redpanda/models/testutil/... -run TestNestedAttributeValidationWithErrors/DEMO
//
// Then comment out the t.Skip() lines in the DEMO tests.
func TestNestedAttributeValidationWithErrors(t *testing.T) {
	t.Run("DEMO_DetectMultipleErrorsInNestedAttributes", func(t *testing.T) {
		// Skip by default - remove this line to see error detection in action
		t.Skip("Demo test: This test intentionally has 6 schema errors to demonstrate validation. Remove t.Skip() to run.")

		// THIS TEST WILL FAIL when run, detecting 6 different types of schema errors:
		// 1. Wrong primitive type: StringType expected, BoolAttribute used
		// 2. Wrong primitive type: Int64Type expected, StringAttribute used
		// 3. Wrong ElementType: ListAttribute with BoolType instead of StringType
		// 4. Missing attribute: retry_count not in schema
		// 5. Wrong nested primitive type: Int64Type expected, StringAttribute used
		// 6. Wrong nested ElementType: ListAttribute with Int64Type instead of StringType

		// Define the CORRECT type definition (what the schema should match)
		correctTypeDefinition := map[string]attr.Type{
			"name":        types.StringType,
			"enabled":     types.BoolType,
			"port":        types.Int64Type,
			"tags":        types.ListType{ElemType: types.StringType},
			"metadata":    types.MapType{ElemType: types.StringType},
			"retry_count": types.Int64Type,
			"config": types.ObjectType{
				AttrTypes: map[string]attr.Type{
					"timeout":     types.Int64Type,
					"max_retries": types.Int64Type,
					"endpoints":   types.ListType{ElemType: types.StringType},
				},
			},
		}

		// Define a schema with MULTIPLE INTENTIONAL ERRORS
		erroneousSchema := map[string]schema.Attribute{
			// ERROR 1: name should be StringAttribute but is BoolAttribute
			"name": schema.BoolAttribute{
				Required:    true,
				Description: "Name of the resource",
			},

			// CORRECT: enabled is BoolAttribute
			"enabled": schema.BoolAttribute{
				Optional: true,
			},

			// ERROR 2: port should be Int64Attribute but is StringAttribute
			"port": schema.StringAttribute{
				Required: true,
			},

			// ERROR 3: tags ElementType should be StringType but is BoolType
			"tags": schema.ListAttribute{
				ElementType: types.BoolType, // WRONG! Should be StringType
				Optional:    true,
			},

			// CORRECT: metadata has correct ElementType
			"metadata": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},

			// ERROR 4: retry_count should be Int64Attribute but is missing entirely

			// Nested object with errors
			"config": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					// ERROR 5: timeout should be Int64Attribute but is StringAttribute
					"timeout": schema.StringAttribute{
						Required: true,
					},

					// CORRECT: max_retries is Int64Attribute
					"max_retries": schema.Int64Attribute{
						Optional: true,
					},

					// ERROR 6: endpoints ElementType should be StringType but is Int64Type
					"endpoints": schema.ListAttribute{
						ElementType: types.Int64Type, // WRONG! Should be StringType
						Optional:    true,
					},
				},
			},
		}

		// Run validation - should detect all 6 errors
		testutil.ValidateSchemaAgainstObjectType(t, erroneousSchema, correctTypeDefinition, "test_resource")

		// The test framework will automatically fail if any t.Errorf was called
		// We expect the following errors:
		// 1. 'test_resource.name': type definition expects StringType but schema is schema.BoolAttribute
		// 2. 'test_resource.port': type definition expects Int64Type but schema is schema.StringAttribute
		// 3. 'test_resource.tags': schema ElementType is basetypes.BoolType but type definition expects basetypes.StringType
		// 4. Type definition has attribute 'test_resource.retry_count' but schema does not
		// 5. 'test_resource.config.timeout': type definition expects Int64Type but schema is schema.StringAttribute
		// 6. 'test_resource.config.endpoints': schema ElementType is basetypes.Int64Type but type definition expects basetypes.StringType
	})

	t.Run("ValidateCorrectNestedAttributes", func(t *testing.T) {
		// Define the type definition
		correctTypeDefinition := map[string]attr.Type{
			"name":     types.StringType,
			"enabled":  types.BoolType,
			"port":     types.Int64Type,
			"tags":     types.ListType{ElemType: types.StringType},
			"metadata": types.MapType{ElemType: types.StringType},
			"config": types.ObjectType{
				AttrTypes: map[string]attr.Type{
					"timeout":     types.Int64Type,
					"max_retries": types.Int64Type,
					"endpoints":   types.ListType{ElemType: types.StringType},
				},
			},
		}

		// Define a CORRECT schema
		correctSchema := map[string]schema.Attribute{
			"name": schema.StringAttribute{
				Required:    true,
				Description: "Name of the resource",
			},

			"enabled": schema.BoolAttribute{
				Optional: true,
			},

			"port": schema.Int64Attribute{
				Required: true,
			},

			"tags": schema.ListAttribute{
				ElementType: types.StringType, // CORRECT
				Optional:    true,
			},

			"metadata": schema.MapAttribute{
				ElementType: types.StringType, // CORRECT
				Optional:    true,
			},

			"config": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"timeout": schema.Int64Attribute{
						Required: true,
					},

					"max_retries": schema.Int64Attribute{
						Optional: true,
					},

					"endpoints": schema.ListAttribute{
						ElementType: types.StringType, // CORRECT
						Optional:    true,
					},
				},
			},
		}

		// This should pass without errors
		testutil.ValidateSchemaAgainstObjectType(t, correctSchema, correctTypeDefinition, "test_resource")
	})

	t.Run("DEMO_ValidateWithNativeGoStructModel", func(t *testing.T) {
		// Skip by default - remove this line to see error detection in action
		t.Skip("Demo test: This test has an intentional ElementType mismatch in nested field. Remove t.Skip() to run.")

		// This test uses native Go structs (not types.Object) to demonstrate
		// validation of deeply nested structures with the model-based approach

		// Define nested model structs
		type ConfigModel struct {
			Timeout    int64    `tfsdk:"timeout"`
			MaxRetries int64    `tfsdk:"max_retries"`
			Endpoints  []string `tfsdk:"endpoints"`
		}

		type ResourceModel struct {
			Name     string            `tfsdk:"name"`
			Enabled  bool              `tfsdk:"enabled"`
			Port     int64             `tfsdk:"port"`
			Tags     []string          `tfsdk:"tags"`
			Metadata map[string]string `tfsdk:"metadata"`
			Config   ConfigModel       `tfsdk:"config"`
		}

		// Define a schema with errors
		erroneousSchema := schema.Schema{
			Attributes: map[string]schema.Attribute{
				"name": schema.StringAttribute{
					Required: true,
				},
				"enabled": schema.BoolAttribute{
					Optional: true,
				},
				"port": schema.Int64Attribute{
					Required: true,
				},
				"tags": schema.ListAttribute{
					ElementType: types.StringType,
					Optional:    true,
				},
				"metadata": schema.MapAttribute{
					ElementType: types.StringType,
					Optional:    true,
				},
				"config": schema.SingleNestedAttribute{
					Optional: true,
					Attributes: map[string]schema.Attribute{
						"timeout": schema.Int64Attribute{
							Required: true,
						},
						"max_retries": schema.Int64Attribute{
							Optional: true,
						},
						// ERROR: endpoints ElementType should be StringType but is Int64Type
						"endpoints": schema.ListAttribute{
							ElementType: types.Int64Type, // WRONG!
							Optional:    true,
						},
					},
				},
			},
		}

		// Validate using the model-based approach
		// This will catch the ElementType mismatch in the nested config.endpoints field
		testutil.ValidateSchemaModelAlignment(t, ResourceModel{}, erroneousSchema)

		// Expected error: endpoints has wrong ElementType (Int64 instead of String)
	})
}
