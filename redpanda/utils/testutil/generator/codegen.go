// Copyright 2023 Redpanda Data, Inc.
//
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path"
	"text/template"
)

const testFileTemplate = `// Code generated by go generate; DO NOT EDIT.
// Generated by: redpanda/models/testutil/generator

package testutil_test

import (
	{{- range .Imports }}
	{{ .Alias }} "{{ .Path }}"
	{{- end }}
)

// allResourceTests contains all discovered resource model-schema pairs
var allResourceTests = []struct {
	name     string
	model    interface{}
	resource resource.Resource
}{
	{{- range .ResourcePairs }}
	{
		name:     "{{ .Name }}",
		model:    {{ .ModelPackageAlias }}.{{ .ModelStruct }}{},
		resource: &{{ .ResourcePackageAlias }}.{{ .ResourceStruct }}{},
	},
	{{- end }}
}

// allDataSourceTests contains all discovered data source model-schema pairs
var allDataSourceTests = []struct {
	name       string
	model      interface{}
	dataSource datasource.DataSource
}{
	{{- range .DataSourcePairs }}
	{
		name:       "{{ .Name }}",
		model:      {{ .ModelPackageAlias }}.{{ .ModelStruct }}{},
		dataSource: &{{ .ResourcePackageAlias }}.{{ .ResourceStruct }}{},
	},
	{{- end }}
}

{{ if .ClusterNestedValidations }}
// clusterNestedObjectValidations contains all discovered nested object validations for cluster resource
var clusterNestedObjectValidations = []struct {
	attributeName string
	typeDefFunc   func() map[string]attr.Type
}{
	{{- range .ClusterNestedValidations }}
	{"{{ .AttributeName }}", cluster.{{ .TypeDefFunc }}},
	{{- end }}
}
{{ end }}
`

// TemplateData holds the data for generating test files
type TemplateData struct {
	Imports                  []ImportInfo
	ResourcePairs            []PairInfo
	DataSourcePairs          []PairInfo
	ClusterNestedValidations []ClusterNestedValidation
}

// ImportInfo represents an import statement with alias and path
type ImportInfo struct {
	Alias string
	Path  string
}

// PairInfo represents a model-resource pairing for test generation
type PairInfo struct {
	Name                 string
	ModelStruct          string
	ResourceStruct       string
	ModelPackageAlias    string
	ResourcePackageAlias string
}

// ClusterNestedValidation represents a nested object validation for the cluster resource
type ClusterNestedValidation struct {
	AttributeName string
	TypeDefFunc   string
}

// GenerateTestFile generates the test file with all discovered model-resource pairs and nested validations
func GenerateTestFile(pairs []ModelResourcePair, nestedValidations []NestedObjectValidation, outputPath string) error {
	data := prepareTemplateData(pairs, nestedValidations)

	tmpl, err := template.New("test").Parse(testFileTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Printf("Warning: failed to format generated code: %v\n", err)
		formatted = buf.Bytes()
	}

	if err := os.WriteFile(outputPath, formatted, 0o600); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}

// prepareTemplateData prepares the data structure for the template
func prepareTemplateData(pairs []ModelResourcePair, nestedValidations []NestedObjectValidation) TemplateData {
	data := TemplateData{
		Imports:                  make([]ImportInfo, 0),
		ResourcePairs:            make([]PairInfo, 0),
		DataSourcePairs:          make([]PairInfo, 0),
		ClusterNestedValidations: make([]ClusterNestedValidation, 0),
	}

	importMap := make(map[string]string) // path -> alias

	importMap["github.com/hashicorp/terraform-plugin-framework/resource"] = "resource"
	importMap["github.com/hashicorp/terraform-plugin-framework/datasource"] = "datasource"

	// Add attr import if we have nested validations
	if len(nestedValidations) > 0 {
		importMap["github.com/hashicorp/terraform-plugin-framework/attr"] = "attr"
	}

	for _, pair := range pairs {
		modelAlias := pair.PackageName

		// Extract resource package name from the import path for example ".../resources/acl" -> "acl"
		resourcePkg := extractPackageName(pair.ResourceImport)
		resourceAlias := resourcePkg + "res"

		importMap[pair.ModelImport] = modelAlias
		importMap[pair.ResourceImport] = resourceAlias

		pairInfo := PairInfo{
			Name:                 pair.Name,
			ModelStruct:          pair.ModelStruct,
			ResourceStruct:       pair.ResourceStruct,
			ModelPackageAlias:    modelAlias,
			ResourcePackageAlias: resourceAlias,
		}

		if pair.Type == "Resource" {
			data.ResourcePairs = append(data.ResourcePairs, pairInfo)
		} else {
			data.DataSourcePairs = append(data.DataSourcePairs, pairInfo)
		}
	}

	// Add nested validations
	for _, validation := range nestedValidations {
		data.ClusterNestedValidations = append(data.ClusterNestedValidations, ClusterNestedValidation(validation))
	}

	for path, alias := range importMap {
		data.Imports = append(data.Imports, ImportInfo{
			Alias: alias,
			Path:  path,
		})
	}

	return data
}

// extractPackageName extracts the package name from an import path for example "github.com/.../resources/acl" -> "acl"
func extractPackageName(importPath string) string {
	return path.Base(importPath)
}
